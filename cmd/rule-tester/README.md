# Rule Tester (`rule-tester`)

The `rule-tester` is a command-line utility for writing, testing, and validating your rules in a fast, offline environment. It allows you to verify the logic of your rulesâ€”including conditions, templates, array operations, and dependencies like KV and timeâ€”without needing a running NATS server or live HTTP endpoints.

This tool is essential for maintaining a high-quality, reliable ruleset and integrating rule validation into a modern CI/CD workflow for both the `rule-router` and `http-gateway` applications.

-----

## Features

*   **Unified Testing**: Test rules for both NATS and HTTP triggers/actions with a single tool.
*   **Array Operations Support**: Full support for testing forEach and array operators.
*   **Trigger-Aware Scaffolding**: Automatically generates test configurations tailored to your rule's specific trigger type (NATS or HTTP).
*   **ForEach Detection**: Intelligently detects forEach operations and generates appropriate array-based test examples.
*   **Linting**: Quickly validate the YAML syntax and structure of all rule files.
*   **Batch Testing**: Run a full suite of tests for your entire ruleset, based on a simple, convention-over-configuration directory structure.
*   **Dependency Mocking**: Isolate your tests by providing mock data for NATS KV stores, mock timestamps for time-based rules, and mock signature verification results.
*   **Output Validation**: Guarantee the correctness of your templates by comparing the rendered action (NATS subject/payload or HTTP URL/method/payload) against an expected output.
*   **Multi-Action Support**: Validates multiple actions generated by forEach operations.
*   **Parallel Execution**: Run tests in parallel for faster feedback.
*   **CI/CD Friendly**: Multiple output formats (human-readable or JSON) for easy integration.

-----

## Testing Workflow

### 1. Scaffolding Your Tests

Start by using the `--scaffold` command on your new rule file. The tool will smartly inspect your rule's trigger and **automatically detect forEach operations** to generate pre-populated configuration that accelerates your test setup.

**Command:**
```bash
rule-tester --scaffold ./rules/my-new-rule.yaml
```

**For Standard Rules:**
```
rules/
â”œâ”€â”€ my-new-rule.yaml
â””â”€â”€ my-new-rule_test/
    â”œâ”€â”€ _test_config.json  # Pre-populated with the correct mock trigger
    â”œâ”€â”€ match_1.json       # Placeholder for a message that SHOULD match
    â””â”€â”€ not_match_1.json   # Placeholder for a message that SHOULD NOT match
```

**For ForEach Rules:**
```
rules/
â”œâ”€â”€ batch-rule.yaml
â””â”€â”€ batch-rule_test/
    â”œâ”€â”€ _test_config.json              # Pre-populated mock trigger
    â”œâ”€â”€ match_1.json                   # Array input (3 items, 2 match filter)
    â”œâ”€â”€ match_1_output.json            # Expected: 2 actions (array format)
    â”œâ”€â”€ not_match_1.json               # Array with no matching items
    â””â”€â”€ not_match_2_empty_array.json   # Empty array edge case
```

**Console Output for ForEach Rules:**
```
âœ“ Detected forEach operation on field: notifications
  Generating array-based test examples...
âœ“ Scaffolded test directory at: batch-rule_test/

ðŸ’¡ TIP: Your rule uses forEach - example test files include:
   â€¢ Array input messages
   â€¢ Array output validation (multiple actions)
   â€¢ Filter condition examples
```

**Example Generated `_test_config.json` (NATS Trigger):**
```json
{
  "mockTrigger": {
    "nats": {
      "subject": "sensors.temperature"
    }
  },
  "mockTime": "2025-10-16T05:30:00Z",
  "headers": {}
}
```

**Example Generated `_test_config.json` (HTTP Trigger):**
```json
{
  "mockTrigger": {
    "http": {
      "path": "/webhooks/github",
      "method": "POST"
    }
  },
  "mockTime": "2025-10-16T05:30:00Z",
  "headers": {}
}
```

### 2. Writing Test Cases

Edit the generated JSON files with your sample message data. The filename itself declares the expected outcome.

*   `match_*.json`: The tester will assert that the rule **must** match.
*   `not_match_*.json`: The tester will assert that the rule **must not** match.

**Standard Rule Example:**
```json
{
  "temperature": 35,
  "deviceId": "sensor-123"
}
```

**ForEach Rule Example:**
```json
{
  "deviceId": "device-123",
  "events": [
    {"eventId": "E1", "type": "motion", "severity": "high"},
    {"eventId": "E2", "type": "motion", "severity": "low"},
    {"eventId": "E3", "type": "door", "severity": "high"}
  ]
}
```

### 3. Running the Tests

Run the batch tester from the root of your project. It will automatically discover and run all tests for both NATS and HTTP rules, including forEach operations.

**Command:**
```bash
rule-tester --test --rules ./rules
```

**Output:**
```
â–¶ RUNNING TESTS in ./rules/

=== RULE: rules/my-nats-rule.yaml ===
  âœ“ match_1.json (5ms)
  âœ“ not_match_1.json (3ms)

=== RULE: rules/batch-rule.yaml ===
  âœ“ match_1.json (12ms)
  âœ“ not_match_1.json (4ms)
  âœ“ not_match_2_empty_array.json (2ms)

--- SUMMARY ---
Total Tests: 5, Passed: 5, Failed: 0
Duration: 26ms
```

-----

## Array Operations Testing

### Output Validation Formats

The rule-tester supports **two output formats** and automatically detects which one to use:

#### Single Action Format (Backward Compatible)
For rules without forEach:
```json
{
  "subject": "alerts.high-temp",
  "payload": {
    "temp": 35
  }
}
```

#### Multiple Actions Format (ForEach)
For rules with forEach:
```json
[
  {
    "subject": "alerts.motion.E1",
    "payload": {
      "eventId": "E1",
      "severity": "high"
    }
  },
  {
    "subject": "alerts.motion.E3",
    "payload": {
      "eventId": "E3",
      "severity": "high"
    }
  }
]
```

**The tester automatically:**
1. Tries to parse as array first (forEach case)
2. Falls back to single object (standard case)
3. Validates action count matches expected
4. Validates each action's subject, payload, and headers

### Testing ForEach Rules

**Example Rule:**
```yaml
- trigger:
    nats:
      subject: "device.events"
  
  conditions:
    - field: "events"
      operator: any
      conditions:
        - field: "type"
          operator: eq
          value: "motion"
  
  action:
    forEach: "events"
    filter:
      - field: "type"
        operator: eq
        value: "motion"
    nats:
      subject: "alerts.motion.{eventId}"
      payload: |
        {
          "eventId": "{eventId}",
          "deviceId": "{@msg.deviceId}"
        }
```

**Test Input** (`match_1.json`):
```json
{
  "deviceId": "device-123",
  "events": [
    {"eventId": "E1", "type": "motion"},
    {"eventId": "E2", "type": "door"},
    {"eventId": "E3", "type": "motion"}
  ]
}
```

**Expected Output** (`match_1_output.json`):
```json
[
  {
    "subject": "alerts.motion.E1",
    "payload": {
      "eventId": "E1",
      "deviceId": "device-123"
    }
  },
  {
    "subject": "alerts.motion.E3",
    "payload": {
      "eventId": "E3",
      "deviceId": "device-123"
    }
  }
]
```

**What Gets Validated:**
- âœ… Action count: 2 (E2 filtered out)
- âœ… Subject templating: `{eventId}` from array element
- âœ… Payload templating: `{@msg.deviceId}` from root message
- âœ… JSON structure of each payload

### Testing Array Operators

**Rule with `any` operator:**
```yaml
conditions:
  - field: "items"
    operator: any
    conditions:
      - field: "status"
        operator: eq
        value: "active"
```

**Test Case** (`match_1.json`):
```json
{
  "items": [
    {"id": 1, "status": "inactive"},
    {"id": 2, "status": "active"},
    {"id": 3, "status": "inactive"}
  ]
}
```

**Result**: Rule matches (because item 2 is active)

**Test Case** (`not_match_1.json`):
```json
{
  "items": [
    {"id": 1, "status": "inactive"},
    {"id": 2, "status": "inactive"}
  ]
}
```

**Result**: Rule does not match (no active items)

### Common Test Scenarios

#### Scenario 1: Multiple Matches
```json
// Input: 3 items, 2 match filter
{"items": [
  {"id": 1, "active": true},
  {"id": 2, "active": true},
  {"id": 3, "active": false}
]}
// Expected: 2 actions
```

#### Scenario 2: No Matches
```json
// Input: 2 items, none match filter
{"items": [
  {"id": 1, "active": false},
  {"id": 2, "active": false}
]}
// Expected: Rule doesn't match (0 actions)
```

#### Scenario 3: Empty Array
```json
// Input: Empty array
{"items": []}
// Expected: Rule doesn't match (any operator returns false)
```

#### Scenario 4: Filter Validation
```json
// Input: 5 items, 2 match filter
// Expected: Exactly 2 actions with correct templating
```

-----

## Advanced Testing

### Output Validation

To ensure your templates are rendered correctly, provide an "expected output" file. For a test message named `match_case.json`, create `match_case_output.json`.

**Example for a NATS Action:**
*   **`match_high_temp_output.json`**:
    ```json
    {
      "subject": "alerts.us-west",
      "payload": {
        "temp": 40
      }
    }
    ```

**Example for an HTTP Action:**
*   **`match_critical_alert_output.json`**:
    ```json
    {
      "url": "https://api.pagerduty.com/incidents",
      "method": "POST",
      "payload": {
        "incident": {
          "title": "High temperature alert for device-123"
        }
      },
      "headers": {
        "Authorization": "Token secret-token-value"
      }
    }
    ```

**Example for ForEach Actions:**
*   **`match_batch_output.json`**:
    ```json
    [
      {
        "subject": "process.item-1",
        "payload": {"id": "item-1", "status": "active"}
      },
      {
        "subject": "process.item-2",
        "payload": {"id": "item-2", "status": "active"}
      }
    ]
    ```

### Mocking Dependencies

The `_test_config.json` file controls the entire simulated environment for a test suite.

*   **`mockTrigger`**: (Required) Defines the event that triggers the rule. Must contain either a `nats` or `http` block.
*   **`mockTime`**: (Optional) An RFC3339 timestamp. All time-based conditions (`@time.hour`, `{@timestamp()}`) will be evaluated against this fixed time.
*   **`headers`**: (Optional) A map of key-value strings to simulate incoming NATS or HTTP headers.
*   **`mockSignature`**: (Optional) A block to mock the result of `@signature.valid` and `@signature.pubkey` for testing security rules.
*   **`mock_kv_data.json`**: (Optional) Create this file in your test directory to provide mock data for KV lookups. The top-level keys are bucket names.

**Example `_test_config.json` with Signature Mocking:**
```json
{
  "mockTrigger": {
    "nats": { "subject": "cmds.door.unlock" }
  },
  "mockSignature": {
    "valid": true,
    "publicKey": "UDXU4RCRBVXEZ..."
  }
}
```

-----

## Full CLI Reference

| Flag | Description |
|---|---|
| `--lint` | Validate the syntax of all `*.yaml` rule files. |
| `--scaffold <path>` | Generate a test directory for a given rule file (detects forEach). |
| `--test` | Run all test suites found in a directory. |
| `--rule <path>` | Path to a single rule file for Quick Check mode. |
| `--message <path>` | Path to a single message file for Quick Check mode. |
| `--subject <subj>` | **(NATS Only)** Manually specify a subject for Quick Check mode. |
| `--kv-mock <path>` | Path to mock KV data file for Quick Check mode. |
| `--output <format>` | Output format: `pretty` (default) or `json`. |
| `--verbose` | Show detailed output for failures. |
| `--parallel <N>` | Number of parallel test workers (default: 4, 0 = sequential). |
| `--no-overwrite` | Prevent scaffold from overwriting an existing test directory. |

-----

## Examples

### Example 1: NATS â†’ NATS Rule

**Rule (`rules/temperature_alert.yaml`):**
```yaml
- trigger:
    nats:
      subject: "sensors.temperature"
  conditions:
    - field: "value"
      operator: gt
      value: 30
  action:
    nats:
      subject: "alerts.high-temp"
      payload: '{"temp": {value}}'
```

**Test Config (`.../_test_config.json`):**
```json
{
  "mockTrigger": {
    "nats": {
      "subject": "sensors.temperature"
    }
  }
}
```

### Example 2: HTTP â†’ NATS Rule (Inbound Webhook)

**Rule (`rules/github_webhook.yaml`):**
```yaml
- trigger:
    http:
      path: "/webhooks/github"
      method: "POST"
  conditions:
    - field: "@header.X-GitHub-Event"
      operator: eq
      value: "pull_request"
  action:
    nats:
      subject: "github.events.pr"
      payload: '{"repo":"{repository.name}","pr":{number}}'
```

**Test Config (`.../_test_config.json`):**
```json
{
  "mockTrigger": {
    "http": {
      "path": "/webhooks/github",
      "method": "POST"
    }
  },
  "headers": {
    "X-GitHub-Event": "pull_request"
  }
}
```

**Test Case (`.../match_pr.json`):**
```json
{
  "repository": { "name": "rule-router" },
  "number": 42
}
```

**Expected Output (`.../match_pr_output.json`):**
```json
{
  "subject": "github.events.pr",
  "payload": {
    "repo": "rule-router",
    "pr": 42
  }
}
```

### Example 3: NATS â†’ HTTP Rule (Outbound Webhook)

**Rule (`rules/pagerduty_alert.yaml`):**
```yaml
- trigger:
    nats:
      subject: "alerts.critical.>"
  action:
    http:
      url: "https://api.pagerduty.com/incidents"
      method: "POST"
      payload: '{"incident":{"title":"{message}"}}'
```

**Test Config (`.../_test_config.json`):**
```json
{
  "mockTrigger": {
    "nats": {
      "subject": "alerts.critical.database"
    }
  }
}
```

**Test Case (`.../match_db_alert.json`):**
```json
{
  "message": "Database connection lost"
}
```

**Expected Output (`.../match_db_alert_output.json`):**
```json
{
  "url": "https://api.pagerduty.com/incidents",
  "method": "POST",
  "payload": {
    "incident": {
      "title": "Database connection lost"
    }
  }
}
```

### Example 4: ForEach Rule (Batch Processing)

**Rule (`rules/batch_alerts.yaml`):**
```yaml
- trigger:
    nats:
      subject: "device.batch"
  
  conditions:
    - field: "alerts"
      operator: any
      conditions:
        - field: "critical"
          operator: eq
          value: true
  
  action:
    forEach: "alerts"
    filter:
      - field: "critical"
        operator: eq
        value: true
    nats:
      subject: "alerts.critical.{alertId}"
      payload: |
        {
          "alertId": "{alertId}",
          "message": "{message}",
          "deviceId": "{@msg.deviceId}"
        }
```

**Test Input (`.../match_1.json`):**
```json
{
  "deviceId": "device-123",
  "alerts": [
    {"alertId": "A1", "critical": true, "message": "High temp"},
    {"alertId": "A2", "critical": false, "message": "Low battery"},
    {"alertId": "A3", "critical": true, "message": "Motion detected"}
  ]
}
```

**Expected Output (`.../match_1_output.json`):**
```json
[
  {
    "subject": "alerts.critical.A1",
    "payload": {
      "alertId": "A1",
      "message": "High temp",
      "deviceId": "device-123"
    }
  },
  {
    "subject": "alerts.critical.A3",
    "payload": {
      "alertId": "A3",
      "message": "Motion detected",
      "deviceId": "device-123"
    }
  }
]
```

**Test Non-Match (`.../not_match_empty.json`):**
```json
{
  "deviceId": "device-123",
  "alerts": []
}
```

-----

## Quick Check Mode

Interactive testing for rapid iteration:

```bash
rule-tester --rule batch_alerts.yaml \
            --message test_input.json
```

**Output (ForEach Rule):**
```
Rule Matched: True
Actions Generated: 2
Processing Time: 1.2ms

--- Rendered Action 1 ---
Type: NATS
Subject: alerts.critical.A1
Payload: {"alertId":"A1","message":"High temp","deviceId":"device-123"}
-----------------------

--- Rendered Action 2 ---
Type: NATS
Subject: alerts.critical.A3
Payload: {"alertId":"A3","message":"Motion detected","deviceId":"device-123"}
-----------------------
```

-----

## Best Practices

### Test Coverage Checklist

For **standard rules**, create tests for:
- âœ… Message that matches all conditions
- âœ… Message that fails each condition individually
- âœ… Edge cases (null values, missing fields)
- âœ… Template variable resolution

For **forEach rules**, additionally test:
- âœ… Multiple matching elements (2-3 items)
- âœ… Single matching element
- âœ… No matching elements (all filtered)
- âœ… Empty array
- âœ… Mixed array (some match, some don't)
- âœ… Non-object elements (should skip gracefully)
- âœ… `@msg` prefix resolution
- âœ… Element field resolution

### Naming Convention

```
match_<scenario>.json         # Should generate actions
match_<scenario>_output.json  # Expected actions
not_match_<reason>.json       # Should NOT generate actions
```

Examples:
- `match_three_items.json` / `match_three_items_output.json`
- `match_single_item.json` / `match_single_item_output.json`
- `not_match_empty_array.json`
- `not_match_all_filtered.json`

### Debugging Failed Tests

Use `--verbose` flag to see detailed information:

```bash
rule-tester --test --rules ./rules --verbose
```

**Verbose output shows:**
- Action count mismatch details
- Which action failed validation
- Template resolution issues
- Filter application results

-----

## CI/CD Integration

### GitHub Actions Example

```yaml
name: Rule Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - uses: actions/setup-go@v4
        with:
          go-version: '1.23'
      
      - name: Build rule-tester
        run: go build -o rule-tester ./cmd/rule-tester
      
      - name: Lint rules
        run: ./rule-tester --lint --rules ./rules
      
      - name: Test rules
        run: ./rule-tester --test --rules ./rules --output json > results.json
      
      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: results.json
```

### JSON Output Format

For CI/CD integration, use `--output json`:

```bash
rule-tester --test --rules ./rules --output json
```

**Output:**
```json
{
  "total": 10,
  "passed": 9,
  "failed": 1,
  "duration_ms": 156,
  "results": [
    {
      "file": "match_1.json",
      "passed": true,
      "duration_ms": 12
    },
    {
      "file": "match_2.json",
      "passed": false,
      "error": "action count mismatch: got 1 actions, expected 2",
      "duration_ms": 8
    }
  ]
}
```

-----

## Troubleshooting

### "Output validation failed"

**Cause**: Generated actions don't match expected output.

**Solution**:
1. Run with `--verbose` to see detailed mismatch
2. Use Quick Check mode to inspect actual output
3. Verify JSON structure in output file
4. Check for array vs single object format

### "Action count mismatch"

**Cause**: ForEach generated different number of actions than expected.

**Solution**:
1. Check filter conditions (might be filtering more/less)
2. Verify input array length
3. Check for non-object elements (skipped)
4. Review forEach field path

### "Template resolution failed"

**Cause**: Variable not found or KV lookup failed.

**Solution**:
1. Check field exists in test message
2. For forEach: use `@msg` prefix for root fields
3. Verify mock KV data is loaded
4. Check variable syntax (`{field}` not `{{field}}`)

-----

## Resources

- [Main README](../../README.md) - Complete rule syntax and features
- [Rule Router README](../rule-router/README.md) - NATS-specific rules
- [HTTP Gateway README](../http-gateway/README.md) - HTTP-specific rules
- [ForEach Examples](../../examples/forEach/) - Array processing examples

For questions or issues, check the troubleshooting section in the main README.
