# Rule Tester (`rule-tester`)

The `rule-tester` is a command-line utility for writing, testing, and validating your rules in a fast, offline environment. It allows you to verify the logic of your rulesâ€”including conditions, templates, array operations, primitive message support, and dependencies like KV and timeâ€”without needing a running NATS server or live HTTP endpoints.

This tool is essential for maintaining a high-quality, reliable ruleset and integrating rule validation into a modern CI/CD workflow for both the `rule-router` and `http-gateway` applications.

-----

## Features

*   **Unified Testing**: Test rules for both NATS and HTTP triggers/actions with a single tool.
*   **Array Operations Support**: Full support for testing forEach and array operators.
*   **Primitive Message Support**: Test rules with strings, numbers, arrays, and objects at the root.
*   **Trigger-Aware Scaffolding**: Automatically generates test configurations tailored to your rule's specific trigger type (NATS or HTTP).
*   **ForEach Detection**: Intelligently detects forEach operations and generates appropriate array-based test examples.
*   **Linting**: Quickly validate the YAML syntax and structure of all rule files.
*   **Batch Testing**: Run a full suite of tests for your entire ruleset, based on a simple, convention-over-configuration directory structure.
*   **Dependency Mocking**: Isolate your tests by providing mock data for NATS KV stores, mock timestamps for time-based rules, and mock signature verification results.
*   **Output Validation**: Guarantee the correctness of your templates by comparing the rendered action (NATS subject/payload or HTTP URL/method/payload) against an expected output.
*   **Multi-Action Support**: Validates multiple actions generated by forEach operations.
*   **Parallel Execution**: Run tests in parallel for faster feedback.
*   **CI/CD Friendly**: Multiple output formats (human-readable or JSON) for easy integration.

-----

## Testing Workflow

### 1. Scaffolding Your Tests

Start by using the `--scaffold` command on your new rule file. The tool will smartly inspect your rule's trigger and **automatically detect forEach operations** to generate pre-populated configuration that accelerates your test setup.

**Command:**
```bash
rule-tester --scaffold ./rules/my-new-rule.yaml
```

**For Standard Rules:**
```
rules/
â”œâ”€â”€ my-new-rule.yaml
â””â”€â”€ my-new-rule_test/
    â”œâ”€â”€ _test_config.json  # Pre-populated with the correct mock trigger
    â”œâ”€â”€ match_1.json       # Placeholder for a message that SHOULD match
    â””â”€â”€ not_match_1.json   # Placeholder for a message that SHOULD NOT match
```

**For ForEach Rules:**
```
rules/
â”œâ”€â”€ batch-rule.yaml
â””â”€â”€ batch-rule_test/
    â”œâ”€â”€ _test_config.json              # Pre-populated mock trigger
    â”œâ”€â”€ match_1.json                   # Array input (3 items, 2 match filter)
    â”œâ”€â”€ match_1_output.json            # Expected: 2 actions (array format)
    â”œâ”€â”€ not_match_1.json               # Array with no matching items
    â””â”€â”€ not_match_2_empty_array.json   # Empty array edge case
```

**Console Output for ForEach Rules:**
```
âœ“ Detected forEach operation on field: notifications
  Generating array-based test examples...
âœ“ Scaffolded test directory at: batch-rule_test/

ðŸ’¡ TIP: Your rule uses forEach - example test files include:
   â€¢ Array input messages
   â€¢ Array output validation (multiple actions)
   â€¢ Filter condition examples
```

**Example Generated `_test_config.json` (NATS Trigger):**
```json
{
  "mockTrigger": {
    "nats": {
      "subject": "sensors.temperature"
    }
  },
  "mockTime": "2025-10-16T05:30:00Z",
  "headers": {}
}
```

**Example Generated `_test_config.json` (HTTP Trigger):**
```json
{
  "mockTrigger": {
    "http": {
      "path": "/webhooks/github",
      "method": "POST"
    }
  },
  "mockTime": "2025-10-16T05:30:00Z",
  "headers": {}
}
```

### 2. Writing Test Cases

Edit the generated JSON files with your sample message data. The filename itself declares the expected outcome.

*   `match_*.json`: The tester will assert that the rule **must** match.
*   `not_match_*.json`: The tester will assert that the rule **must not** match.

**Standard Rule Example:**
```json
{
  "temperature": 35,
  "deviceId": "sensor-123"
}
```

**ForEach Rule Example:**
```json
{
  "deviceId": "device-123",
  "events": [
    {"eventId": "E1", "type": "motion", "severity": "high"},
    {"eventId": "E2", "type": "motion", "severity": "low"},
    {"eventId": "E3", "type": "door", "severity": "high"}
  ]
}
```

**Primitive Message Examples:**
```json
"ERROR: Connection timeout"
```

```json
[100, 150, 200, 250]
```

```json
["device-001", "device-002", "device-003"]
```

### 3. Running the Tests

Run the batch tester from the root of your project. It will automatically discover and run all tests for both NATS and HTTP rules, including forEach operations and primitive messages.

**Command:**
```bash
rule-tester --test --rules ./rules
```

**Output:**
```
â–¶ RUNNING TESTS in ./rules/

=== RULE: rules/my-nats-rule.yaml ===
  âœ“ match_1.json (5ms)
  âœ“ not_match_1.json (3ms)

=== RULE: rules/batch-rule.yaml ===
  âœ“ match_1.json (12ms)
  âœ“ not_match_1.json (4ms)
  âœ“ not_match_2_empty_array.json (2ms)

=== RULE: rules/primitive-rule.yaml ===
  âœ“ match_string.json (3ms)
  âœ“ match_array.json (8ms)

--- SUMMARY ---
Total Tests: 7, Passed: 7, Failed: 0
Duration: 37ms
```

-----

## Array Operations Testing

### Output Validation Formats

The rule-tester supports **two output formats** and automatically detects which one to use:

#### Single Action Format (Backward Compatible)
For rules without forEach:
```json
{
  "subject": "alerts.high-temp",
  "payload": {
    "temp": 35
  }
}
```

#### Multiple Actions Format (ForEach)
For rules with forEach:
```json
[
  {
    "subject": "alerts.motion.E1",
    "payload": {
      "eventId": "E1",
      "severity": "high"
    }
  },
  {
    "subject": "alerts.motion.E3",
    "payload": {
      "eventId": "E3",
      "severity": "high"
    }
  }
]
```

**The tester automatically:**
1. Tries to parse as array first (forEach case)
2. Falls back to single object (standard case)
3. Validates action count matches expected
4. Validates each action's subject, payload, and headers

### Testing ForEach Rules

**Example Rule:**
```yaml
- trigger:
    nats:
      subject: "device.events"
  
  conditions:
    operator: and
    items:
      - field: "events"
        operator: any
        conditions:
          operator: and
          items:
            - field: "type"
              operator: eq
              value: "motion"
  
  action:
    forEach: "events"
    filter:
      operator: and
      items:
        - field: "type"
          operator: eq
          value: "motion"
    nats:
      subject: "alerts.motion.{eventId}"
      payload: |
        {
          "eventId": "{eventId}",
          "deviceId": "{@msg.deviceId}"
        }
```

**Test Input** (`match_1.json`):
```json
{
  "deviceId": "device-123",
  "events": [
    {"eventId": "E1", "type": "motion"},
    {"eventId": "E2", "type": "door"},
    {"eventId": "E3", "type": "motion"}
  ]
}
```

**Expected Output** (`match_1_output.json`):
```json
[
  {
    "subject": "alerts.motion.E1",
    "payload": {
      "eventId": "E1",
      "deviceId": "device-123"
    }
  },
  {
    "subject": "alerts.motion.E3",
    "payload": {
      "eventId": "E3",
      "deviceId": "device-123"
    }
  }
]
```

**What Gets Validated:**
- âœ… Action count: 2 (E2 filtered out)
- âœ… Subject templating: `{eventId}` from array element
- âœ… Payload templating: `{@msg.deviceId}` from root message
- âœ… JSON structure of each payload

### Testing Array Operators

**Rule with `any` operator:**
```yaml
conditions:
  operator: and
  items:
    - field: "items"
      operator: any
      conditions:
        operator: and
        items:
          - field: "status"
            operator: eq
            value: "active"
```

**Test Case** (`match_1.json`):
```json
{
  "items": [
    {"id": 1, "status": "inactive"},
    {"id": 2, "status": "active"},
    {"id": 3, "status": "inactive"}
  ]
}
```

**Result**: Rule matches (because item 2 is active)

**Test Case** (`not_match_1.json`):
```json
{
  "items": [
    {"id": 1, "status": "inactive"},
    {"id": 2, "status": "inactive"}
  ]
}
```

**Result**: Rule does not match (no active items)

### Testing Primitive Messages

**Rule with string at root:**
```yaml
- trigger:
    nats:
      subject: "logs.raw"
  conditions:
    operator: and
    items:
      - field: "@value"
        operator: contains
        value: "ERROR"
  action:
    nats:
      subject: "alerts.error"
      payload: '{"message": "{@value}"}'
```

**Test Input** (`match_1.json`):
```json
"ERROR: Connection timeout"
```

**Expected Output** (`match_1_output.json`):
```json
{
  "subject": "alerts.error",
  "payload": {
    "message": "ERROR: Connection timeout"
  }
}
```

**Rule with array at root:**
```yaml
- trigger:
    nats:
      subject: "metrics.batch"
  action:
    forEach: "@items"
    filter:
      operator: and
      items:
        - field: "@value"
          operator: gt
          value: 150
    nats:
      subject: "metrics.high"
      payload: '{"value": {@value}}'
```

**Test Input** (`match_1.json`):
```json
[100, 150, 200, 250]
```

**Expected Output** (`match_1_output.json`):
```json
[
  {
    "subject": "metrics.high",
    "payload": {"value": 200}
  },
  {
    "subject": "metrics.high",
    "payload": {"value": 250}
  }
]
```

### Common Test Scenarios

#### Scenario 1: Multiple Matches
```json
// Input: 3 items, 2 match filter
{"items": [
  {"id": 1, "active": true},
  {"id": 2, "active": true},
  {"id": 3, "active": false}
]}
// Expected: 2 actions
```

#### Scenario 2: No Matches
```json
// Input: 2 items, none match filter
{"items": [
  {"id": 1, "active": false},
  {"id": 2, "active": false}
]}
// Expected: Rule doesn't match (0 actions)
```

#### Scenario 3: Empty Array
```json
// Input: Empty array
{"items": []}
// Expected: Rule doesn't match (any operator returns false)
```

#### Scenario 4: Primitive Array
```json
// Input: String array
{"deviceIds": ["dev-1", "dev-2", "dev-3"]}
// Expected: 3 actions (access via @value)
```

#### Scenario 5: Array at Root
```json
// Input: Number array at root
[10, 20, 30]
// Expected: Access via @items field
```

-----

## Advanced Testing

### Output Validation

To ensure your templates are rendered correctly, provide an "expected output" file. For a test message named `match_case.json`, create `match_case_output.json`.

**Example for a NATS Action:**
*   **`match_high_temp_output.json`**:
    ```json
    {
      "subject": "alerts.us-west",
      "payload": {
        "temp": 40
      }
    }
    ```

**Example for an HTTP Action:**
*   **`match_critical_alert_output.json`**:
    ```json
    {
      "url": "https://api.pagerduty.com/incidents",
      "method": "POST",
      "payload": {
        "incident": {
          "title": "High temperature alert for device-123"
        }
      },
      "headers": {
        "Authorization": "Token secret-token-value"
      }
    }
    ```

**Example for ForEach Actions:**
*   **`match_batch_output.json`**:
    ```json
    [
      {
        "subject": "process.item-1",
        "payload": {"id": "item-1", "status": "active"}
      },
      {
        "subject": "process.item-2",
        "payload": {"id": "item-2", "status": "active"}
      }
    ]
    ```

### Mocking Dependencies

The `_test_config.json` file controls the entire simulated environment for a test suite.

*   **`mockTrigger`**: (Required) Defines the event that triggers the rule. Must contain either a `nats` or `http` block.
*   **`mockTime`**: (Optional) An RFC3339 timestamp. All time-based conditions (`@time.hour`, `{@timestamp()}`) will be evaluated against this fixed time.
*   **`headers`**: (Optional) A map of key-value strings to simulate incoming NATS or HTTP headers.
*   **`mockSignature`**: (Optional) A block to mock the result of `@signature.valid` and `@signature.pubkey` for testing security rules.
*   **`mock_kv_data.json`**: (Optional) Create this file in your test directory to provide mock data for KV lookups. The top-level keys are bucket names.

**Example `_test_config.json` with Signature Mocking:**
```json
{
  "mockTrigger": {
    "nats": { "subject": "cmds.door.unlock" }
  },
  "mockSignature": {
    "valid": true,
    "publicKey": "UDXU4RCRBVXEZ..."
  }
}
```

-----

## Full CLI Reference

| Flag | Description |
|---|---|
| `--lint` | Validate the syntax of all `*.yaml` rule files. |
| `--scaffold <path>` | Generate a test directory for a given rule file (detects forEach). |
| `--test` | Run all test suites found in a directory. |
| `--rule <path>` | Path to a single rule file for Quick Check mode. |
| `--message <path>` | Path to a single message file for Quick Check mode. |
| `--subject <subj>` | **(NATS Only)** Manually specify a subject for Quick Check mode. |
| `--kv-mock <path>` | Path to mock KV data file for Quick Check mode. |
| `--output <format>` | Output format: `pretty` (default) or `json`. |
| `--verbose` | Show detailed output for failures. |
| `--parallel <N>` | Number of parallel test workers (default: 4, 0 = sequential). |
| `--no-overwrite` | Prevent scaffold from overwriting an existing test directory. |

-----

## Examples

### Example 1: NATS â†’ NATS Rule

**Rule (`rules/temperature_alert.yaml`):**
```yaml
- trigger:
    nats:
      subject: "sensors.temperature"
  conditions:
    operator: and
    items:
      - field: "value"
        operator: gt
        value: 30
  action:
    nats:
      subject: "alerts.high-temp"
      payload: '{"temp": {value}}'
```

**Test Config (`.../_test_config.json`):**
```json
{
  "mockTrigger": {
    "nats": {
      "subject": "sensors.temperature"
    }
  }
}
```

### Example 2: HTTP â†’ NATS Rule (Inbound Webhook)

**Rule (`rules/github_webhook.yaml`):**
```yaml
- trigger:
    http:
      path: "/webhooks/github"
      method: "POST"
  conditions:
    operator: and
    items:
      - field: "@header.X-GitHub-Event"
        operator: eq
        value: "pull_request"
  action:
    nats:
      subject: "github.events.pr"
      payload: '{"repo":"{repository.name}","pr":{number}}'
```

**Test Config (`.../_test_config.json`):**
```json
{
  "mockTrigger": {
    "http": {
      "path": "/webhooks/github",
      "method": "POST"
    }
  },
  "headers": {
    "X-GitHub-Event": "pull_request"
  }
}
```

**Test Case (`.../match_pr.json`):**
```json
{
  "repository": { "name": "rule-router" },
  "number": 42
}
```

**Expected Output (`.../match_pr_output.json`):**
```json
{
  "subject": "github.events.pr",
  "payload": {
    "repo": "rule-router",
    "pr": 42
  }
}
```

### Example 3: NATS â†’ HTTP Rule (Outbound Webhook)

**Rule (`rules/pagerduty_alert.yaml`):**
```yaml
- trigger:
    nats:
      subject: "alerts.critical.>"
  action:
    http:
      url: "https://api.pagerduty.com/incidents"
      method: "POST"
      payload: '{"incident":{"title":"{message}"}}'
```

**Test Config (`.../_test_config.json`):**
```json
{
  "mockTrigger": {
    "nats": {
      "subject": "alerts.critical.database"
    }
  }
}
```

**Test Case (`.../match_db_alert.json`):**
```json
{
  "message": "Database connection lost"
}
```

**Expected Output (`.../match_db_alert_output.json`):**
```json
{
  "url": "https://api.pagerduty.com/incidents",
  "method": "POST",
  "payload": {
    "incident": {
      "title": "Database connection lost"
    }
  }
}
```

### Example 4: ForEach Rule (Batch Processing)

**Rule (`rules/batch_alerts.yaml`):**
```yaml
- trigger:
    nats:
      subject: "device.batch"
  
  conditions:
    operator: and
    items:
      - field: "alerts"
        operator: any
        conditions:
          operator: and
          items:
            - field: "critical"
              operator: eq
              value: true
  
  action:
    forEach: "alerts"
    filter:
      operator: and
      items:
        - field: "critical"
          operator: eq
          value: true
    nats:
      subject: "alerts.critical.{alertId}"
      payload: |
        {
          "alertId": "{alertId}",
          "message": "{message}",
          "deviceId": "{@msg.deviceId}"
        }
```

**Test Input (`.../match_1.json`):**
```json
{
  "deviceId": "device-123",
  "alerts": [
    {"alertId": "A1", "critical": true, "message": "High temp"},
    {"alertId": "A2", "critical": false, "message": "Low battery"},
    {"alertId": "A3", "critical": true, "message": "Motion detected"}
  ]
}
```

**Expected Output (`.../match_1_output.json`):**
```json
[
  {
    "subject": "alerts.critical.A1",
    "payload": {
      "alertId": "A1",
      "message": "High temp",
      "deviceId": "device-123"
    }
  },
  {
    "subject": "alerts.critical.A3",
    "payload": {
      "alertId": "A3",
      "message": "Motion detected",
      "deviceId": "device-123"
    }
  }
]
```

**Test Non-Match (`.../not_match_empty.json`):**
```json
{
  "deviceId": "device-123",
  "alerts": []
}
```

### Example 5: Primitive String Message

**Rule (`rules/string_log.yaml`):**
```yaml
- trigger:
    nats:
      subject: "logs.raw"
  conditions:
    operator: and
    items:
      - field: "@value"
        operator: contains
        value: "ERROR"
  action:
    nats:
      subject: "alerts.error"
      payload: '{"message": "{@value}"}'
```

**Test Input (`.../match_1.json`):**
```json
"ERROR: Connection timeout"
```

**Expected Output (`.../match_1_output.json`):**
```json
{
  "subject": "alerts.error",
  "payload": {
    "message": "ERROR: Connection timeout"
  }
}
```

### Example 6: Primitive Array ForEach

**Rule (`rules/device_batch.yaml`):**
```yaml
- trigger:
    nats:
      subject: "devices.provision"
  action:
    forEach: "deviceIds"
    nats:
      subject: "provision.{@value}"
      payload: '{"deviceId": "{@value}", "action": "{@msg.action}"}'
```

**Test Input (`.../match_1.json`):**
```json
{
  "action": "register",
  "deviceIds": ["dev-001", "dev-002", "dev-003"]
}
```

**Expected Output (`.../match_1_output.json`):**
```json
[
  {
    "subject": "provision.dev-001",
    "payload": {"deviceId": "dev-001", "action": "register"}
  },
  {
    "subject": "provision.dev-002",
    "payload": {"deviceId": "dev-002", "action": "register"}
  },
  {
    "subject": "provision.dev-003",
    "payload": {"deviceId": "dev-003", "action": "register"}
  }
]
```

-----

## Quick Check Mode

Interactive testing for rapid iteration:

```bash
rule-tester --rule batch_alerts.yaml \
            --message test_input.json
```

**Output (ForEach Rule):**
```
Rule Matched: True
Actions Generated: 2
Processing Time: 1.2ms

--- Rendered Action 1 ---
Type: NATS
Subject: alerts.critical.A1
Payload: {"alertId":"A1","message":"High temp","deviceId":"device-123"}
-----------------------

--- Rendered Action 2 ---
Type: NATS
Subject: alerts.critical.A3
Payload: {"alertId":"A3","message":"Motion detected","deviceId":"device-123"}
-----------------------
```

**Primitive Message:**
```bash
rule-tester --rule string_log.yaml \
            --message <(echo '"ERROR: Test"')
```

-----

## Best Practices

### Test Coverage Checklist

For **standard rules**, create tests for:
- âœ… Message that matches all conditions
- âœ… Message that fails each condition individually
- âœ… Edge cases (null values, missing fields)
- âœ… Template variable resolution

For **forEach rules**, additionally test:
- âœ… Multiple matching elements (2-3 items)
- âœ… Single matching element
- âœ… No matching elements (all filtered)
- âœ… Empty array
- âœ… Mixed array (some match, some don't)
- âœ… Non-object elements (should skip gracefully)
- âœ… `@msg` prefix resolution
- âœ… Element field resolution

For **primitive message rules**, additionally test:
- âœ… String at root
- âœ… Number at root
- âœ… Boolean at root
- âœ… Array at root (via `@items`)
- âœ… String array elements (via `@value`)
- âœ… Number array elements (via `@value`)
- âœ… Empty values

### Naming Convention

```
match_<scenario>.json         # Should generate actions
match_<scenario>_output.json  # Expected actions
not_match_<reason>.json       # Should NOT generate actions
```

Examples:
- `match_three_items.json` / `match_three_items_output.json`
- `match_single_item.json` / `match_single_item_output.json`
- `match_string_message.json` / `match_string_message_output.json`
- `match_primitive_array.json` / `match_primitive_array_output.json`
- `not_match_empty_array.json`
- `not_match_all_filtered.json`

### Debugging Failed Tests

Use `--verbose` flag to see detailed information:

```bash
rule-tester --test --rules ./rules --verbose
```

**Verbose output shows:**
- Action count mismatch details
- Which action failed validation
- Template resolution issues
- Filter application results
- Wrapping details for primitives

-----

## CI/CD Integration

### GitHub Actions Example

```yaml
name: Rule Tests
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - uses: actions/setup-go@v4
        with:
          go-version: '1.23'
      
      - name: Build rule-tester
        run: go build -o rule-tester ./cmd/rule-tester
      
      - name: Lint rules
        run: ./rule-tester --lint --rules ./rules
      
      - name: Test rules
        run: ./rule-tester --test --rules ./rules --output json > results.json
      
      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: results.json
```

### JSON Output Format

For CI/CD integration, use `--output json`:

```bash
rule-tester --test --rules ./rules --output json
```

**Output:**
```json
{
  "total": 10,
  "passed": 9,
  "failed": 1,
  "duration_ms": 156,
  "results": [
    {
      "file": "match_1.json",
      "passed": true,
      "duration_ms": 12
    },
    {
      "file": "match_2.json",
      "passed": false,
      "error": "action count mismatch: got 1 actions, expected 2",
      "duration_ms": 8
    }
  ]
}
```

-----

## Troubleshooting

### "Output validation failed"

**Cause**: Generated actions don't match expected output.

**Solution**:
1. Run with `--verbose` to see detailed mismatch
2. Use Quick Check mode to inspect actual output
3. Verify JSON structure in output file
4. Check for array vs single object format

### "Action count mismatch"

**Cause**: ForEach generated different number of actions than expected.

**Solution**:
1. Check filter conditions (might be filtering more/less)
2. Verify input array length
3. Check for non-object elements (now supported via `@value`)
4. Review forEach field path

### "Template resolution failed"

**Cause**: Variable not found or KV lookup failed.

**Solution**:
1. Check field exists in test message
2. For forEach: use `@msg` prefix for root fields
3. For primitives: use `@value` for values, `@items` for root arrays
4. Verify mock KV data is loaded
5. Check variable syntax (`{field}` not `{{field}}`)

### "Primitive message not working"

**Cause**: Wrong field access pattern.

**Solution**:
1. String at root â†’ use `{@value}`
2. Array at root â†’ use `@items` field
3. String array elements â†’ use `{@value}` in forEach
4. Number array elements â†’ use `{@value}` in forEach
5. Objects â†’ use normal `{field}` syntax (no wrapping)

-----

## Resources

- [Main README](../../README.md) - Complete rule syntax and features
- [Rule Router README](../rule-router/README.md) - NATS-specific rules
- [HTTP Gateway README](../http-gateway/README.md) - HTTP-specific rules
- [ForEach Examples](../../examples/forEach/) - Array processing examples
- [Primitive Examples](../../examples/primitives/) - Primitive message examples

For questions or issues, check the troubleshooting section in the main README.
